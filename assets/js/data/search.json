[ { "title": "Flink源码解析系列---RPC框架", "url": "/GloryJin.github.io/posts/FlinkRPC/", "categories": "", "tags": "Flink, Rpc, Akka", "date": "2021-03-19 18:32:20 +0800", "snippet": "前言对于Flink中多个组件基于Rpc实现通信，其底层RPC通信框架基于Akka实现，本文着重分析Flink中的Rpc框架实现机制及梳理其通信流程。Akka介绍由于Flink底层Rpc是基于Akka实现，我们先了解下Akka的基本使用。Akka是一个开发并发、容错和可伸缩应用的框架。它是Actor Model的一个实现，和Erlang的并发模型很像。在Actor模型中，所有的实体被认为是独立的actors。actors和其他actors通过发送异步消息通信。Actor模型的强大来自于异步。它也可以显式等待响应，这使得可以执行同步操作。但是，强烈不建议同步消息，因为它们限制了系统的伸缩性。..." }, { "title": "一次线上线程池过载导致的性能劣化问题定位", "url": "/GloryJin.github.io/posts/00001/", "categories": "问题定位", "tags": "Java, Concurrent", "date": "2020-01-01 13:32:20 +0800", "snippet": "问题现象今日线上机器，发现CPU长时间使用率超高，通过jstack定位到具体执行线程，发现大量XXX线程一直在后台执行。分析日志，发现有大量task加入线程池的日志打印，但是线程并未得到执行，导致积压大量task，而执行效率不高。问题定位受限定位到执行缓慢的代码处： ExecutorService XML_PARSE_EXECUTOR_SERVICE = Executors.newFixedThreadPool(100); ExecutorService.execute(Runnable);newFixedThreadPool的Java实现逻辑是： public sta..." }, { "title": "blog模板", "url": "/GloryJin.github.io/posts/demo/", "categories": "", "tags": "blog", "date": "2017-08-21 18:32:20 +0800", "snippet": "You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.To add..." } ]
