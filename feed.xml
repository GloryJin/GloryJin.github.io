<feed xmlns="http://www.w3.org/2005/Atom"> <id>/GloryJin.github.io/</id><title>JayD</title><subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle> <updated>2021-05-17T10:37:59+08:00</updated> <author> <name>JayD</name> <uri>/GloryJin.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="/GloryJin.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en-US" href="/GloryJin.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator> <rights> © 2021 JayD </rights> <icon>/GloryJin.github.io/assets/img/favicons/favicon.ico</icon> <logo>/GloryJin.github.io/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Flink源码解析系列---RPC框架</title><link href="/GloryJin.github.io/posts/FlinkRPC/" rel="alternate" type="text/html" title="Flink源码解析系列---RPC框架" /><published>2021-03-19T18:32:20+08:00</published> <updated>2021-05-17T10:26:43+08:00</updated> <id>/GloryJin.github.io/posts/FlinkRPC/</id> <content src="/GloryJin.github.io/posts/FlinkRPC/" /> <author> <name>JayD</name> </author> <summary> 前言 对于Flink中多个组件基于Rpc实现通信，其底层RPC通信框架基于Akka实现，本文着重分析Flink中的Rpc框架实现机制及梳理其通信流程。 Akka介绍 由于Flink底层Rpc是基于Akka实现，我们先了解下Akka的基本使用。 Akka是一个开发并发、容错和可伸缩应用的框架。它是Actor Model的一个实现，和Erlang的并发模型很像。在Actor模型中，所有的实体被认为是独立的actors。actors和其他actors通过发送异步消息通信。Actor模型的强大来自于异步。它也可以显式等待响应，这使得可以执行同步操作。但是，强烈不建议同步消息，因为它们限制了系统的伸缩性。每个actor有一个邮箱(mailbox)，它收到的消息存储在里面。另外，每一个actor维护自身单独的状态。一个Actors网络如下所示： 2.1 AkkaRpcActor Akka... </summary> </entry> <entry><title>一次线上线程池过载导致的性能劣化问题定位</title><link href="/GloryJin.github.io/posts/00001/" rel="alternate" type="text/html" title="一次线上线程池过载导致的性能劣化问题定位" /><published>2020-01-01T13:32:20+08:00</published> <updated>2020-01-01T13:32:20+08:00</updated> <id>/GloryJin.github.io/posts/00001/</id> <content src="/GloryJin.github.io/posts/00001/" /> <author> <name>JayD</name> </author> <category term="问题定位" /> <summary> 问题现象 今日线上机器，发现CPU长时间使用率超高，通过jstack定位到具体执行线程，发现大量XXX线程一直在后台执行。分析日志，发现有大量task加入线程池的日志打印，但是线程并未得到执行，导致积压大量task，而执行效率不高。 问题定位 受限定位到执行缓慢的代码处： ExecutorService XML_PARSE_EXECUTOR_SERVICE = Executors.newFixedThreadPool(100); ExecutorService.execute(Runnable); newFixedThreadPool的Java实现逻辑是： public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExec... </summary> </entry> <entry><title>blog模板</title><link href="/GloryJin.github.io/posts/demo/" rel="alternate" type="text/html" title="blog模板" /><published>2017-08-21T18:32:20+08:00</published> <updated>2021-03-10T11:10:07+08:00</updated> <id>/GloryJin.github.io/posts/demo/</id> <content src="/GloryJin.github.io/posts/demo/" /> <author> <name>JayD</name> </author> <summary> You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated. To add new posts, simply add a file in the _posts directory that follows the convention YYYY-MM-DD-name-... </summary> </entry> </feed>
